import { Maybe } from "./maybe";
export declare type Pred<T> = (t: T) => boolean;
export declare type Fn<T, R> = (t: T) => R;
export declare const otherwise: <T>(_?: T | undefined) => boolean;
export declare const defined: <T>(t: Maybe<T>) => t is T;
export declare const not: <T>(p: Pred<T>) => Pred<T>;
export declare function wiith<T1, T2, T3, T4, T5, R>(fn: (...args: [T1, T2, T3, T4, T5]) => R, args: Fn<void, [T1, T2, T3, T4, T5]>): R;
export declare function wiith<T1, T2, T3, T4, R>(fn: (...args: [T1, T2, T3, T4]) => R, args: Fn<void, [T1, T2, T3, T4]>): R;
export declare function wiith<T1, T2, T3, R>(fn: (...args: [T1, T2, T3]) => R, args: Fn<void, [T1, T2, T3]>): R;
export declare function wiith<T1, T2, R>(fn: (...args: [T1, T2]) => R, args: Fn<void, [T1, T2]>): R;
export declare function wiith<T1, A extends [T1], R>(fn: (...args: A) => R, args: Fn<void, [T1]>): R;
export declare function using<T1, T2, T3, T4, T5, R>(a: [T1, T2, T3, T4, T5], fn: (...args: [T1, T2, T3, T4, T5]) => R): R;
export declare function using<T1, T2, T3, T4, R>(a: [T1, T2, T3, T4], fn: (...args: [T1, T2, T3, T4]) => R): R;
export declare function using<T1, T2, T3, R>(a: [T1, T2, T3], fn: (...args: [T1, T2, T3]) => R): R;
export declare function using<T1, T2, R>(a: [T1, T2], fn: (...args: [T1, T2]) => R): R;
export declare function using<T1, A extends [T1], R>(a: A, fn: (...args: A) => R): R;
export declare const guard: <T, R>(guards: [Pred<T>, Fn<T, R>][]) => Fn<T, R>;
export declare const max: Fn<number[], number>;
